

              ===============================================
              Release notes for the Genode OS Framework 22.05
              ===============================================

                               Genode Labs



; intro
; @nfeske


WireGuard
#########

[https://www.wireguard.com/ - WireGuard] is a protocol for encrypted, virtual
private networks (VPNs) with the goal of bringing ease-of-use and
state-of-the-art network security together. Furthermore, it is designed to be
implemented both light-weighted and highly performant at the same time. For
years now, we were keen to support WireGuard also in Genode as a native
standard solution for peer-to-peer encryption. With Genode 22.05, we could
finally accomplish that goal.

After we had considered all the options, we choose to port the Linux kernel
implementation of WireGuard using our modernized DDE-Linux tool set. The
outcome is a user-land component that acts as client to one NIC session and one
Uplink session. At the Uplink session, the WireGuard component plays the role
of a VPN-internal network device that communicates plain-text with the VPN
participants. At the NIC session, however, the component drives an encrypted
UDP tunnel through the public network towards other WireGuard instances.

In Genode, a WireGuard instance receives its parameters through the component
configuration with the peer configuration being re-configurable:

! <config private_key="0CtU34qsl97IGiYKSO4tMaF/SJvy04zzeQkhZEbZSk0="
!         listen_port="49001">
!
!   <peer public_key="GrvyALPZ3PQ2AWM+ovxJqnxSqKpmTyqUui5jH+C8I0E="
!         endpoint_ip="10.1.2.1"
!         endpoint_port="49002"
!         allowed_ip="10.0.9.2/32" />
!
! </config>

A typical integration scenario would use two instances of Genode's NIC router.
One router serves the public network side of WireGuard and connects to the
internet via the device driver whereas the other router uses the private
network side of WireGuard as uplink interface. In this scenario, there's no way
around the WireGuard tunnel towards the Internet even when looking only at
components and sessions. However, we can accomplish the same goal with only one
router instance in contexts that allow us to trust in the integrity of the
router's own security domains.

[image wireguard_integration]
  A typical integration scenario for WireGuard

For more details on how to integrate and route WireGuard in Genode, you may
refer to the new run scripts 'wg_ping_inwards.run', 'wg_ping_outwards.run',
'wg_lighttpd.run', and 'wg_fetchurl.run', all located in 'repos/dde_linux/run'.

Please be aware that this is only the first official version of Genode's
WireGuard component. Although we are convinced of the quality the underlying
Linux implementation proved to have over the years, we strongly recommend not
to base security-critical scenarios on Genode's port before it had the time to
mature through real-world testing as well.

For the whole story behind the new WireGuard support in Genode, have a look at
the corresponding
[http://genodians.org/m-stein/2022-05-31-wireguard-1 - Genodians article].


New generation of DDE-Linux-based PC drivers
############################################

; @cnuke @alex-ab @skalk

With the last release we started to apply the new DDE Linux approach to the
Linux-based PC drivers. The first driver to be converted was the USB host-controller
driver. In this release we finished up this line of work and by now all
remaining Linux-based PC drivers are converted and updated. Those drivers
now share the same kernel version 5.14.21 and its configuration and reside
in the 'pc' repository.

    dde_linux: add virt_linux lx_emul flavor
    
    To support device-less protocol-stacks only ports, we can use a
    Virt I/O Linux kernel flavor, and export the lx_kit/lx_emul parts
    not depending on platform API and devices.
    
    Ref #4397

Based on the groundwork laid by the 'pc_usb_host_drv' driver we started
working on the Intel display and Intel wireless drivers. With the
stumbling blocks already out of the way, namely the x86 support in the
DDE Linux, we could focus entirely on the intricacies of each driver.

In case of the Intel display driver we could get rid of all our patches to
the kernel we previousily needed to manage the display connectors. Due to
the update we gained support for newer Intel Gen11 and Gen12 graphic
generations found in recent Intel CPUs. The old driver was removed and the
new driver is now called 'pc_intel_fb_drv'. The configuration, however,
stayed compatible and is documented in detail in the README of the driver.

The Intel wireless driver also profited from the version update as it now
supports 802.11ax capable devices. In particular the driver was tested with
Intel Wi-Fi6 AX201 cards. The driver's unique physique where the component not
only incorporates the driver but also the supporting user-land supplicant
required changes to the way the Linux emulation environment is initialized.
We utilize the VFS 'wifi' plugin that is executed during the component
start-up to prepare the emulation environment.

The following snippet shows how to configure the driver:

!<start name="pc_wifi_drv" caps="250">
!  <resource name="RAM" quantum="32M"/>
!  <provides><service name="Nic"/></provides>
!  <config>
!    <libc stdout="/dev/null" stderr="/dev/null" rtc="/dev/rtc"/>
!    <vfs>
!      <dir name="dev">
!        <log/> <null/> <rtc/> <wifi/>
!        <jitterentropy name="random"/>
!        <jitterentropy name="urandom"/>
!      </dir>
!    </vfs>
!  </config>
!  <route>
!    <service name="Rtc"> <any-child /> </service>
!    <any-service> <parent/> <any-child /> </any-service>
!  </route>
!</start

Apart from the added VFS plugin the configuration remained unchanged and using
the new driver is opaque to the user. The old driver was removed and the new
driver is now called 'pc_wifi_drv'. Instead of preparing the 'dde_linux' port
the 'libnl' and 'wpa_supplicant' ports are now required

! tool/ports/prepare libnl wpa_supplicant

for building the driver. Those ports are used unchanged from the old driver
and will be updated in a later release.


; commit e95f0a409d7a3cc7563d4f9e17842f0edaf014af
; Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
; Date:   Tue Mar 8 16:20:38 2022 +0100
; 
;     lx_emul: add implementation for Genode's USB C-API
;     
;     Fix #4444

Additionally to both driver updates we wrapped up working on the
'pc_usb_host_drv' driver component by enabling the UHCI host-controller driver.
Support for such controllers was omitted in the previous release and supporting
the driver required us to add I/O port support to the 'lx_kit' for x86. The
'legacy_pc_usb_host_drv' driver component is removed in for favour of the new
one. Furthermore the Genode C-API for USB glue code, which was initially copied
from the i.MX8 USB host-controller driver, was consolidated and moved into the
'dde_linux' repository where it now is referenced by all recent USB
host-controller drivers.


With all updated drivers in place it was time to make inventory and
de-duplicate the drivers since each driver accumulated redundant bits and
pieces of code and this consolidation effort simplyfied things greatly. We
moved most of the code shared by all drivers into the 'pc_lx_emul' library,
which is the back bone of those ported drivers. Since not all of them require
the same sophistication when it comes to the implementation we followed the
same modular pattern already established in the 'dde_linux' repository. This
allows for mixing and matching of the available dummy implementations.


commit f985de52f302e51680923425a66c9821a31c32e4
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Tue Feb 1 08:55:03 2022 +0100

    app/pci_decode: prepare pci device information
    
    To discharge the generic platform driver from certain PCI bus scanning,
    and ACPI + kernel specifics, this commit introduces a new component,
    which consumes the acpi drivers report and the platform_info from core
    to prepare a devices ROM for the platform driver that contains all
    PCI devices and its resources.
    
    Fix genodelabs/genode#4495

commit 72853554bd24047e6a1a54d70d667e6911cdf7ef
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Thu Apr 28 14:41:17 2022 +0200

    platform_drv: add report facility
    
    By adding a 'report' node to the platform driver's configuration
    one can enable either devices or config reports. The devices
    report contains all devices and their detailed state, as well as
    whether it is already in use or not. The config report contains
    one by one the current configuration of the platform driver.
    Moreover, this commit adds a README file describing the facilities
    of the platform driver.
    
    Fix genodelabs/genode#4386

commit 2cdfc4d827230ee2de3fc2ca9a3c455a0b2ebb8c
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Mon May 2 11:37:04 2022 +0200

    platform_drv: wait for device's availability
    
    Instead of returning an invalid device capability when a device
    is (not yet) available, e.g. a PCI device is requested before the
    PCI bus got parsed accordingly, we check the device capability
    within the Platform::Connection utilities, and register temporarily
    an Io_signal_handler to wait for changes of the devices ROM, and
    try the device aquisition again. Thereby, simple drivers so not have
    to take the burden to do so.
    
    To enable this feature for all drivers, we always have to export a
    devices ROM, but limit the information about physical resources
    (I/O memory addresses, IRQ numbers, I/O port ranges) to clients with
    'info=yes' in their policy description.
    
    Fix genodelabs/genode#4496

commit 02cdd11502fde40e312e347b510fdec7df51322b
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Mon May 2 14:56:14 2022 +0200

    platform_drv: consider IRQ type, mode, polarity
    
    Parse the devices ROM for additional interrupt information, and
    pass them to the IRQ connection when needed.
    
    Fix genodelabs/genode#4497

commit 57aab46fc3e45e26b962320eb249be9a61cf2869
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Tue Mar 1 17:05:45 2022 +0100

    platform: introduce I/O ports in API
    
    * Introduces Platform::Device::Io_port client utility
    * Implements I/O ports as common device resources in platform driver
    
    Fix genodelabs/genode#4436

commit 9713014130b68de09e275138414a35c5a057d879
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Mon Mar 7 15:32:00 2022 +0100
commit 21ab73d5f90cf99063eeee0b994d1e42a4d86af6
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Tue May 3 13:36:27 2022 +0200

    platform_drv: add PCI device support
    
    * Parse PCI specific information from devices ROM
    * Enable DMA, I/O memory and I/O port access dependent on BARs in config space
    * Introduce device PD for Nova + IOMMU support
    * Enable MSIs if available
    * Add PCI specific policy rules
    
    Fixes genodelabs/genode#4502

commit 580d9f9941cad355323ee60048c07e2ca7b5765a
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Wed May 11 14:27:09 2022 +0200

    platform_drv: make devices ROM name configureable
    
    Fix genodelabs/genode#4504


Updated and new documentation
#############################

Genode Platforms
----------------

; @nfeske

: <div class="visualClear"><!-- --></div>
: <p>
:  <div style="clear: both; float: left; margin-right:20px;">
:   <a class="internal-link" href="https://genode.org">
:    <img class="image-inline" src="https://genode.org/documentation/genode-platforms-title.png">
:   </a>
:  </div>
: </p>

* Working with bare-bones Linux kernels
* Network driver based on DDE-Linux
* Display
* Touchscreen
* Clocks, resets, and power controls
* Modem control and telephony

:Second revision of the Genode Platforms document:

  [https://genode.org/documentation/genode-platforms-22-05.pdf]


Genode Foundations
------------------

The "Genode Foundations" book received its annual update. It is available at
the [https://genode.org] website as a PDF document and an online version.
The most noteworthy additions and changes are:

: <div class="visualClear"><!-- --></div>
: <p>
:  <div style="clear: both; float: left; margin-right:20px;">
:   <a class="internal-link" href="https://genode.org">
:    <img class="image-inline" src="https://genode.org/documentation/genode-foundations-title.png">
:   </a>
:  </div>
: </p>

* Revised under-the-hood section about the base-hw kernel,
* Adaptation to changed repository structure (pc repository, SoC-specific
  repositories),
* Updated API documentation ('Attempt' pattern, and
* Adjusted package-management description to changed pubkey/download location.

: <div class="visualClear"><!-- --></div>

To examine the changes in detail, please refer to the book's
[https://github.com/nfeske/genode-manual/commits/master - revision history].


Base framework and OS-level infrastructure
##########################################

Revised tracing facilities
==========================

Even though a light-weight event tracing mechanism has been with Genode since
[https://genode.org/documentation/release-notes/13.08#Light-weight_event_tracing - version 13.08],
in practice, this powerful tool remains sparingly used because it is arguable
less convenient than plain old debug instrumentation.

Event though the trace-logger component introduced later in version
[https://genode.org/documentation/release-notes/18.02#New_trace-logging_component - version 18.02]
tried to lower the barrier, tracing remains being an underused feature.
The current release brings a number of usability improvements that will
hopefully make the tool more attractive for routine use.

Concise human-oriented output format
------------------------------------

First, we changed the output format of the trace logger to become
better suitable for human consumption, reducing syntactic noise and
filtering out repetitive information. For example, when instrumenting
the VFS server in Sculpt using the new GENODE_TRACE_TSC utility (see below),
the trace logger now generates tabular output as follows.

! Report 4
!
! PD "init -> runtime -> arch_vbox6 -> vbox -> " ----------------
!  Thread "vCPU"           at (0,0)  total:12909024 recent:989229
!  Thread "vCPU"           at (1,0)  total:5643234  recent:786437
!
! PD "init -> runtime -> ahci-0.fs" -----------------------------
!  Thread "ahci-0.fs"      at (0,0)  total:910497   recent:6335
!  Thread "ep"             at (0,0)  total:0        recent:0
!   71919692932: TSC process_packets: 8005M (4998 calls, last 4932K)
!   71921558516: TSC process_packets: 8006M (4999 calls, last 1596K)
!   71922760220: TSC process_packets: 8007M (5000 calls, last 1006K)
!   71929853586: TSC process_packets: 8009M (5001 calls, last 1840K)
!   71931315246: TSC process_packets: 8011M (5002 calls, last 1253K)
!   72127999920: TSC process_packets: 8016M (5003 calls, last 5606K)
!   72129568198: TSC process_packets: 8018M (5004 calls, last 1345K)
!   77161908178: TSC process_packets: 8029M (5005 calls, last 11349K)
!   77643225736: TSC process_packets: 8029M (5006 calls, last 217K)
!   89422100594: TSC process_packets: 8035M (5007 calls, last 5656K)
!   89422123632: TSC process_packets: 8035M (5008 calls, last 1342)
!  Thread "signal handler" at (0,0)  total:36329    recent:3001
!  Thread "signal_proxy"   at (0,0)  total:51838    recent:13099
!  Thread "pdaemon"        at (0,0)  total:97184    recent:332
!  Thread "vdrain"         at (0,0)  total:1266     recent:286
!  Thread "vrele"          at (0,0)  total:1904     recent:516
!
! PD "init -> runtime -> nic_drv" -------------------------------
!  Thread "nic_drv"        at (0,0)  total:34044    recent:897
!  Thread "signal handler" at (0,0)  total:369      recent:142
!
! ...

Subjects that belong to the same PD are grouped together. The formerly
optional affinity and activity options have been removed. Those
information are now unconditionally displayed. The trace entries
belonging to a thread appear as slightly indented. Trace subjects with
no activity do not produce any output. This way, the new version can
be easily used capture CPU usage of all threads over time, as a possible
alternative to the top tool, which gives only momentarily sampled information.


Straight-forward trace logging with Sculpt OS
---------------------------------------------

Second, we added the trace-logger utility to the default set of packages
along with an optional launcher. With this change, only two steps are
needed to use the tracing mechanism with the
[https://genode.org/documentation/release-notes/22.02#Framework_for_special-purpose_Sculpt-based_operating_systems - modularized Sculpt]:

# Add 'trace_logger' to the 'launcher:' list of the .sculpt file

# Either manually select the 'trace_logger' from the '+' menu,
  or add the following entry to the deploy configuration:

  ! <start name="trace_logger"/>

By default, the trace logger is configured to trace all threads executed in
the runtime subsystem and to print a report every 10 seconds. This default
policy can be refined in the launcher's '<config>' node. Note that the trace
logger does not respond to configuration changes during runtime. Changes come
into effect not before restarting the component.


Capturing performance measurements as trace events
--------------------------------------------------

Finally, to leverage the high efficiency of the tracing mechanism for
performance analysis, we complement the convenient
[https://genodians.org/nfeske/2021-04-07-performance - GENODE_LOG_TSC]
measurement device provided by _base/log.h_ with new versions that target the
trace buffer. The new macros GENODE_TRACE_TSC and GENODE_TRACE_TSC_NAMED
thereby simplify the capturing of highly accurate time-stamp-counter-based
measurements for performance-critical code paths that prohibit the use of
regular log messages.


Memcopy and memset optimization
===============================

With the improving support for the Zynq-7000 SoC, it was time to collect a few
basic performance metrics. For the purpose of evaluating memory throughput,
there exists a test suite in 'libports/run/memcpy.run'. It takes a couple of
measurements for different memcpy and memset implementations. There also exists
a Makefile in 'libports/src/test/memcpy/linux' to build a similar test suite for
Linux that serves as a baseline. By comparing the results, we get an indicator
of whether our board support is setting up the hardware correctly.  Looking at
the numbers for the Zynq-7000 SoC, however, we were puzzled about why we
achieved significantly less memcpy throughput on Genode than on Linux. This
eventually sparked an in-depth investigation of memcpy implementations and of
the Cortex-A9's memory subsystem.

As it turned out, the major difference was caused by our Linux tests hitting the
kernel's copy-on-write optimization and, therefore, accidentally mimicking a
memset scenario rather than a memcpy scenario. Nevertheless, in the debugging
process, we were able to identify a few low-hanging fruits for general
optimization of Genode's memset and memcpy implementations:
Replacing the bytewise memset implementation with a wordwise memset yielded a
speedup of ~6 on Cortex-A9 (base-hw) and x86 (base-linux). Similarly, we
achieved a memcpy speedup of ~3 on x86. On arm_v7, we also experimented with
the preloading instruction (pld) and L2 prefetching. On Zynq-7000 (Cortex-A9),
we gained a speedup of ~2-3 by tuning these parameters.



Extended black-hole component
=============================

; @m-stein

commit 046ebc3d3493445e913d046ef9a9569d46fee1d8
Author: Martin Stein <martin.stein@genode-labs.com>
Date:   Fri Mar 11 22:34:57 2022 +0100

    black_hole: provide ROM service
    
    Ref #4419

commit 50fc2aa2519e5c57b006ed13e0bb974bd10c5549
Author: Martin Stein <martin.stein@genode-labs.com>
Date:   Mon Mar 14 17:30:33 2022 +0100

    black_hole: provide Gpu service
    
    Ref #4419

commit ecd4006514691694f2253c4f617fb1c91ff86be2
Author: Martin Stein <martin.stein@genode-labs.com>
Date:   Thu Apr 7 17:24:36 2022 +0200

    black_hole: initial support for Usb service
    
    The service is merely announced but trying to request a session always causes a
    Service_denied exception. This helps in scenarios where the client is
    won't open a session anyway but expects the service to be available. This is
    considered a temporary solution.
    
    Ref #4419

commit 6a61b60a5db9afd4a8ae5939cbaa3fa00dad9d3d
Author: Martin Stein <martin.stein@genode-labs.com>
Date:   Fri Apr 8 13:03:22 2022 +0200

    black_hole: serve real USB sessions
    
    * The server now answers session requests with a session instead of an
      exception#
    * The test expects a session but doesn't access it so far
    
    Ref #4419


Refined low-level block I/O interfaces
======================================

In the original version of the 'Block::Connection::Job' API introduced in
[https://genode.org/documentation/release-notes/19.05#Modernized_block-storage_interfaces - version 19.05],
split read/write operations were rather difficult to accommodate, and
remained largely unsupported by clients of the block-session interface. In
practice, this limitation was side-stepped by dimensioning the default I/O
buffer sizes large enough to avoid splitting. The current release addresses
this limitation by changing the meaning of the 'offset' parameter of the
'produce_write_content' and 'consume_read_result' hook functions. The value
used to reflect the absolute byte position. In the new version, it is relative
to the job's operation.
_This API change requires the adaptation of existing block-session clients._

We adapted all block-session clients accordingly, including part_block,
vfs/rump, vfs/fatfs, and Genode's ARM virtual machine monitor. Those
components thereby became able to work with arbitrary block I/O buffer sizes.


Improved touch-event support
============================

Until recently, Genode's GUI stack largely relies on the notion of absolute
pointer position. For targeting touch-screen devices, our initial approach
was the translation of touch events to absolution motion events using the
event-filter component
([https://genode.org/documentation/release-notes/21.11#Event_filter_for_converting_touch_to_pointer_input] - version 21.11).

However, the event types are subtle different, which creates uncertainties.
Whereas a pointer has always a defined (most recent) position that can be used
to infer a hovered UI element in any situation, touch input yields a valid
position only while touching. Because the nature of both event types are
different, the conversion of touch input to pointer motion can only be an
intermediate solution. The current release enhances several components of
Genode's GUI stack with ability to handle touch events directly.

In particular, the nitpicker GUI server has become able to take touch events
into consideration for steering the keyboard focus and the routing of
input-event sequences. The window-manager component (wm) has been enhanced to
transform touch events similarly to motion events by using one virtual
coordinate system per window. Finally, the menu-view component, which
implements the rudimentary widget set as used by Sculpt OS' administrative
user interface, evaluates touch events for generating hover reports now.
Combined, these changes make the existing GUI stack fit for our anticipated
touch-screen based usage scenarios such as the user interface for Genode on
the PinePhone.


Platforms
#########

PinePhone
=========

Telephony
~~~~~~~~~

The current release introduces the principle ability to issue and receive
voice calls with the PinePhone. This work involved two topics. First,
we had to tackle the integration, configuration, and operation of the LTE
modem. The second piece of the puzzle was the configuration of the audio paths
between the mic, the speaker, and the modem. Since the complexity of those
topics would exceed the scope of the release documentation, the technical
details are covered in the following dedicated article.

:Pine fun - Telephony _(Roger, Roger?)_:

  [https://genodians.org/ssumpf/2022-05-09-telephony]

[image pinephone_telephony]

The image above illustrates a simple system exemplified by the
[https://github.com/genodelabs/genode-allwinner/blob/master/run/modem_pinephone.run - modem_pinephone.run]
script. It allows a terminal emulator on a host machine connected to
the serial connector of the Pinephone to interact with the command interface
of the modem, e.g., allowing the user to unlock the SIM card via the 'AT+CPIN'
command, or to issue a call using the 'ATD' command.


Custom system-control processor (SCP) firmware
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Battery lifetime is one of the most pressing concerns for mobile phones.
While exploring the PinePhone hardware, we discovered early on that the key
for sophisticated energy management lies in the so-called system control
processor (SCP), which is a low-power companion microcontroller that
complements the high-performance application processor. The SCP can remain
active even if the device is visibly switched off.
Surprisingly, even though its designated purpose is rather narrow, the SCP is a
freely programmable general-purpose CPU (called AR100) with ultimate access to
every corner of the SoC. It can control all peripherals including the modem,
and access the entirety of physical memory.

In contrast to most consumer devices, which operate their SCPs with proprietary
firmware, the PinePhone gives users the freedom to use an open-source
firmware called [https://github.com/crust-firmware/crust - Crust].
Moreover, the Crust developers thoroughly documented their findings of the
[https://linux-sunxi.org/AR100 - AR100 limitations] and its
[https://linux-sunxi.org/AR100/HardwareSharing - interplay with the ARM CPU].

Given that the Crust firmware was specifically developed to augment a
Linux-based OS with suspend-resume functionality, its fixed-function feature
set is rather constrained. For running Genode on the PinePhone, we'd like to
move more freely, e.g., letting the SCP interact with the modem while the
application processor is powered off. To break free from the limitations of a
fixed-function feature set of an SCP firmware implemented in C, we explored
the opportunity to deploy a minimal-complexity Forth interpreter as the basis
for a custom SCP firmware. The story behind this line of development is
covered by the following dedicated article:

:Darling, I FORTHified my PinePhone!:

  [https://genodians.org/nfeske/2022-03-29-pinephone-forth]


Inter-communication between SCP and ARM
---------------------------------------

To enable a tight interplay of Genode with the SCP, we introduce a new
[https://github.com/genodelabs/genode-allwinner/tree/master/include/scp_session - interface] and
[https://github.com/genodelabs/genode-allwinner/tree/master/src/drivers/scp/a64 - driver]
for supplying and invoking custom functionality to the SCP at runtime.
The new "Scp" service allows clients to supply snippets of Forth code for
execution at the SCP and retrieve the result. Both the program and the result
are constrained to 1000 bytes. Hence, the loading of larger programs may need
multiple subsequent 'Scp::Connection::execute' calls.

As illustrated by the example
[https://github.com/genodelabs/genode-allwinner/blob/staging/run/a64_scp_drv.run - a64_scp_drv.run]
script, the mechanism supports multiple clients. Since the SCP's state is
global, however, all clients are expected to behave cooperatively. Given the
SCP's ultimate power, SCP clients must be fully trusted anyway.

As a nice tidbit for development, the PinePhone-specific SCP firmware features
a break-in debug shell for interactive use over UART that can be activated by
briefly connecting the INT and GND
[https://wiki.pine64.org/index.php/PinePhone#Pogo_pins - pogo pins].
Note that this interactive debugging facility works independently from the
application processor. Hence, it can be invoked it at any time, e.g., to
inspect any hardware register while running a regular Linux distribution on
the phone.


NXP i.MX8
=========

; @skalk

commit 05b2a5063546361bcc0f783c0d6a00f230407e96
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Mon May 16 16:07:03 2022 +0200

    imx8mq: add Pcie host controller driver
    
    The driver configures all devices it gets assigned, and scans
    the first device behind the Pcie controller. All devices it
    finds are summarized in a platform driver compatible PCI device
    report.

commit 56cf717a080c6ad09f43fc4caf03a92ac81a38a9
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Mon May 16 16:04:01 2022 +0200

    mnt_reform2: add Pcie host controller settings

commit 58a8a2c13aad8a9c0c9902ddea6fae03619626cf
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Mon Aug 2 15:41:01 2021 +0200

    mnt_reform2: enable PCI-x IOMUXC settings


Xilinx Zynq
===========

For the Zynq-7000 SoCs, we focused on two main topics in this release. First, we
leveraged the aforementioned improvements on the generic platform driver to
handle the (dis)appearance of devices in consequence of FPGA reconfiguration.
Second, we applied our new DDE Linux approach in order to port the SD card
driver.

The platform driver for the Xilinx Zynq is now available as
_src/zynq_platform_drv_. The default devices ROMs are provided by the
_raw/[board]-devices_ archives. In addition to the generic driver, it features
the readout of clock frequencies. You can use _zynq_clocks.run_ to dump the
frequencies of all clocks.

Since the Xilinx Zynq comprises an FPGA that can be reconfigured at run time,
we also need to handle the appearance and disappearance of devices. For this
purpose, we added a driver manager that consumes the platform driver's devices
report and launches resp. kills device drivers accordingly. This scenario is
accompanied by the _pkg/drivers_fpga-zynq_ archive that assembles the _devices_
ROM for the platform driver depending on the FPGA's reconfiguration state.
The figure below illustrates this scenario: The subsystem provided by the
_pkg/drivers_fpga-zynq_ archive is a replacement for the platform driver. It
consumes the _fpga.bit_ ROM that contains the FPGA's bitstream. Once the
bitstream has been loaded, the _fpga_devices_ ROM is merged with the _devices_
ROM provided by the _raw/[board]-devices_ archive. The _policy_ ROM contains the
config of the internal zynq_platform_driver (policies and reporting config).
By enabling device reporting, the zynq_driver_manager is able to react upon
device changes and updates the _init.config_ for a drivers subsystem
accordingly.  An example is available in _run/zynq_driver_manager.run_.

[image zynq_driver_manager]

As a prerequisite for port the first driver for the Zynq following our new DDE
Linux approach, we added a zynq_linux target that builds a stripped-down Linux
kernel for the Xilinx Zynq. Although Xilinx provides its own a vendor kernel,
most drivers have been mainlined. To eliminate version mismatch issues, we
therefore use our mainline Linux port from _repos/dde_linux_ instead. With this
foundation, we were able to port the SD card driver, which is now available as
_src/zynq_sd_card_drv_.
